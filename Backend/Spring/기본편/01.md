## SOLID

## 

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만
- 이 책임의 기준은 애매
- 중요한 기준은 변경
  - 변경을 할시에 파급 효과가 적으면 SRP 잘 따른것

### OCP 개방-폐쇄 원칙

- 확장에는 열려있으나 변경에는 닫혀야한다
- 다형성을 이용
  - ex) 운전자 Class, 차량 Class -> 어떠한 차량 객체가 들어가도 운전자는 운전 가능
    - 운전자의 변경은 X, 차량의 종류 확장 O

### LSP 리스코프 치환 원칙

- 특정 인터페이스를 상속받아 구현체를 생성할떄 인터페이스 규약을 어겨서는 안된다
- ex) 자동차 인터페이스에서 엑셀 기능 -> 시속+10 -> 구현체에서 이 규약을 여겨서는 안됨

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 I/F -> 운전 I/F, 정비 I/F 로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야하며 구체화에 의존하면 안됨
- 즉 구현 클래스에 집중하지말고 인터페이스에 의존하게끔
  - 역할(Role)에 의존하게 해라
  - 운전자는 자동차(역할)에 의존해야하지 차종에 의존해야하면 안된다

### 정리

- 객체 지향의 핵심은 다형성
  - 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없음
  - 다형성 만으로는 구현 객체를 변경할 떄 클라이언트 코드도 함꼐 변경됨
  - 즉 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 개발함에 있어서 역할과 구현을 구분
  - 이상적으로는 항상 개발시에 인터페이스를 만들고 기능 구현
- 하지만 매번 인터페이스 만들면 비용 발생
  - 기능 확장의 가능성이 없다면 바로 구현체 만들자

## DI

- 위의 다형성 Issue에 대해서 해결하기 위해 만들어진 개념
- 즉 OCP, DIP를 지키기 위한 기능