# Operating System

`하드웨어를 관리하며 하드웨어와 응용 프로그램 사이에서 인터페이스 역할을 하여 시스템의 동작을 제어하는 시스템 소프트웨어`

- [프로세스](#프로세스)

- [멀티 프로세스](#멀티-프로세스)

- [스레드](#스레드)

- [멀티 스레드](#멀티-스레드)

- [멀티 스레드 vs 멀티 프로세스](#멀티-스레드-vs-멀티-프로세스)

- [동기화 문제](#동기화-문제)



## 프로세스

> 실행 중인 프로그램을 의미하며 메모리에 적재되어 CPU의 할당을 받으며 스케줄링의 대상이 되는 것

- 메모리에 올라와 실행되고 있는 프로그램(*.exe)의 인스턴스

- HDD에 존재하는 프로그램을 실행시키면 이를 위해 메모리 할당이 이뤄지고 할당된 메모리 영역에 바이너리 코드가 올라간다. 이때부터 프로세스라고 칭한다

- OS로부터 할당받는 자원

  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap을 위한 독립된 메모리 공간

- 메모리 구조

  - Code 영역 : 프로그램을 실행시키는 실행 파일 내의 명령어 할당
  - Data 영역 : 전역, static 변수 할당(+ 초기화 안된거는 bss, 초기화 된건 data)
  - Stack 영역 : 지역변수, 매개변수, 리턴값 등을 위한 영역
  - Heap 영역 : 동적 할당을 위한 영역
  - Stack은 위에서 아래로, Heap은 아래에서 위로

- 특징

  - 프로세스는 각각 독립된 영역(Code, Data, Stack, Heap)을 OS로부터 할당받는다

    ![](https://user-images.githubusercontent.com/55429912/120060193-47a94a80-c091-11eb-8dd4-7e49dca2302f.png)

  - 프로세스상 최소 1개의 스레드 보유(메인 스레드)

  - 각 프로세스는 별도의 주소 공간에서 독립되어 실행된다. 그러므로 서로의 자원에 접근하기 위해서는 IPC(Inter-process communication, 프로세스간 통신)을 사용해야한다



## 멀티 프로세스

> 두개 이상의 프로세서(CPU)가 하나 이상의 작업을 동시에 처리하는 것처럼 보이는 것(병렬 처리)

**장점**

- 안전성
  - 메모리 침범 문제를 OS 차원에서 해결
  - 여러 개의 프로세서에 분산 시, 한 프로세스가 정지되더라도 시스템은 정지되지 않고 전보다 처리 속도만 느려짐

**단점**

- 작업량이 늘어날 수록 오버헤드 발생, Context Switching으로 인한 성능 저하

  > 오버헤드 : 어떠한 작업을 처리하는데 드는 간접적인 처리 시간, 메모리



## 스레드

> 프로세스 내에서 수행되는 여러 흐름의 단위 (프로세스의 실행 단위, a.k.a light-weight process)

- 특징
  - 스레드는 프로세스 내의 Code, Data, Heap 영역은 서로 공유하되, Stack만 각각 별도로 할당 받는다

    ![](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

  - 또한 스레드는 스레드 ID, PC(실행할 명령문 주소값), 레지스터 집합, 스택으로 구성됨

  - 한 스레드가 프로세스 자원 변경시, 다른 이웃 스레드(sibling thread)도 변경값 즉시 확인 가능

- 장점

  - 메모리 공유로 인해 시스템 자원 소모 감소
  - 응답시간 단축
  - Context Switching에 대한 오버헤드가 줄어듬(Stack만 switching하면 되기 때문)

- 단점

  - 자원 동기화에 신경써야한다.
    

- 프로세스와의 차이점

  - 프로세스는 자신만의 고유 공간 존재, 다른 프로세스와의 통신은 IPC를 통해서
  - 스레드는 다른 스레드와 자원을 공유한다



- 스택을 독립적으로 할당하는 이유

  - 스택은 매개변수, 지역변수, 리턴 주소 등을 저장하기 위한 메모리 공간. 즉, 독립적인 함수 호출이 가능하다는 것이며 독립적인 실행 흐름을 가진다는 것
  - 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 가지기 위한 최소 조건으로 스택은 분리

  

- PC Register를 스레드별로 독립적이게 할당하는 이유
  - PC 값은 명령어가 어디까지 처리 되었는지 그 주소값을 가리킨다.
  - 스레드는 CPU를 할당받았다가 다시 선점당하기 때문에 그 실행 위치를 저장할 독립적인 공간 필요
    

## 멀티 스레드

> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 병렬처리 하는 것

스레드들이 공유 메모리(Code, Data, Heap)을 통해 다수의 작업을 동시에 처리하도록 함

장점 : 독립적인 프로세스 대비 공유 메모리만큼의 시간, 자원 손실 감소, 전역 변수, 정적 변수에 대한 공유 가능

단점 : 안정성 문제. 하나의 스레드가 공유 메모리 공간의 Data를 망가뜨리면 모든 스레드 동작 불능



## 멀티 스레드 vs 멀티 프로세스

> 시스템에 따라 적합/부적합으로 나뉘며 장단점이 극명하다

- 멀티 스레드?
  - 장점
    - 멀티 스레드는 멀티 프로세스에 비해 적은 공간을 차지
    - context switching이 빠르다 => Stack만 처리하기 때문
    - IPC가 아닌 스레드간 메모리 공유로 인해 응답, 처리 속도 향상
  - 단점
    - 하지만, 공용 공간으로 인해 안정성 문제와 자원 동기화 문제에 대한 임계 영역 기법 처리 필요
- 멀티 프로세스?
  - 장점
    - 하나의 프로세스가 죽어도 독립적이기에 다른 프로세스에 영향 x
  - 단점
    - 하지만, 멀티 스레드보다 많은 자원을 차지하는 단점이 존재
    - 프로세스 간의 context switching시에 캐시 메모리에 대한 데이터까지 초기화 되므로 오버헤드 커짐
    - IPC를 통해 통신해야기에 처리 비용 및 응답 시간 더 오래 걸림

둘 다 동시에 여러 작업을 처리한다는 점에서 목표는 같지만 시스템에 따라 다르게 적용



## 임계 영역(Critical Section)

> 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 영역에 대해 접근하는 코드의 일부



**임계 영역 문제?**

`프로세스들이 임계 영역에 동시 접근 시 발생하는 동기화 문제`



**임계 영역 문제를 처리하기 위한 조건**

1. 상호 배제(Mutual Exclusion)
   - 하나의 프로세스가 임계 영역에 있다면 다른 프로세스 출입 불가
2. 진행(Progress)
   - 임계 영역에 존재하는 프로세스가 없을 시 동시에 임계 영역에 접근하려는 프로세스가 여럿일 시, 그 순서를 적절히 결정해주어야 한다
3. 한정된 대기(Bounded Waiting)
   - 임계 영역에 접근하기 위해 대기하는 프로세스의 Starvation을 방지하기 위해 한번 임계영역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 주어야 한다



## Thread-Safe

> 멀티스레드 환경에서 여러 스레드가 동시에 공유 자원 접근 시, 의도한 대로 동작하게끔 하는 것



- Mutual Exclusion(상호 배제)
  - Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역을 동기화 기법으로 제어(ex : Semaphore, Mutex)
- Re-entrancy
  - 어떤 함수가 스레드에 호출되어 실행중일때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바르게 주어져야 한다.
- Thread-safe storage
  - 공유 자원에 대한 사용을 최대한 줄이고 스레드에서만 접근 가능한 저장소를 통해 동시 접근을 방지한다.
- Atomic Operations
  - 데이터 변경시 Atomic하게 데이터에 접근하도록



## 동기화 문제

> 한정적인 자원에 여러 스레드가 동시 접근하는 문제 존재
>
> 이를 방지하기 위해 **여러 스레드에서 하나의 자원에 대한 처리 권한 및 순서를 조정**하는 기법



#### 스레드 동기화

1. **실행 순서**의 동기화
   - 스레드의 실행 순서를 정해서 한번에 하나의 스레드만 작업하도록 하는 것
2. **메모리 접근**에 대한 동기화
   - 메모리 관점에서의 동시 접근을 막는 것
   - 실행 순서가 아닌 한 순간에 하나의 스레드만 임계 영역에 접근하도록 하는 것



#### 동기화 기법

- **유저 모드**의 동기화
  - 커널의 힘을 빌리지 않는 동기화 기법(커널 코드 실행 x)
  - **성능상 이점**이 존재, **기능상의 제한점** 존재
  - 임계 구역 기반의 동기화, 인터락 함수 기반의 동기화
- **커널 모드**의 동기화
  - 커널에서 제공하는 동기화 기능 사용
  - 커널 모드로의 변경이 필요. 즉, 성능 저하, 하지만 다양한 기능 활용 가능
  - 세마포어, 뮤텍스, 모니터 등등



#### 유저 모드 동기화

##### 1. 임계 구역 기반 동기화

- 열쇠를 얻은 프로세스만 임계 구역에 들어갈 수 있다. 즉, 한번에 하나의 스레드만 접근 가능
- 임계 구역 진입을 위해 **Critical Section Object**를 얻는다
- 다른 스레드가 열쇠를 가지고 있을 시에는 반환 전까지 블로킹된다. 열쇠가 반환되면 블로킹 상태에서 빠져나와 열쇠를 가지고 임계 구역에 진입

##### 2. 인터락 함수 기반 동기화

- 함수 내부적으로 한 순간에 하나의 스레드에 의해서만 임계 구역 실행되도록 동기화
- 임계 구역 기반의 동기화도 내부적으로 인터락 함수 기반으로 구현된다
- 유저 모드 기반이라 속도가 빠르다



#### 커널 모드 동기화

##### 1. 세마포어 (Semaphore)

- 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막는다
- 동시에 접근할 수 있는 '허용 가능 갯수'를 갖고 있는 Counter
  - ex) 화장실에 비유해서 화장실 칸이 4개고 키가 4개(Counter) 라면 최대 4명까지 대기없이 사용 가능
- Counter의 개수에 따라 분류됨
  - 1개 : Binary Semaphore => 사실상 Mutex
  - 2개 이상 : Counting Semaphore
- 세마포어는 소유 불가
  - 하지만 세마포어를 소유하지 않은 다른 스레드가 세마포어 해제 가능

##### 2. 뮤텍스 (Mutex)

- 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막는다
- 임계 영역에 대한 서로 다른 스레드들의 Running Time이 겹치지 않게하기 위함
- 뮤텍스 객체를 동시에 두 스레드에서 사용 불가
- 일종의 Lock 메커니즘으로 공유 자원에 대한 locking과 unlocking을 사용
- Lock에 대한 소유권이 있으며 lock을 가지고 있을 경우에만 공유 자원에 접근 가능, Lock을 가진 사람만 반납 가능
- 무조건 1개의 열쇠만 가질 수 있음

##### 3. 모니터 (Monitor)

- Mutex(Lock)과 Condition Variables를 가지고 있는 Synchronization 매커니즘
- 임계 구역에 하나의 스레드만 진입 가능



| 모드 |            이름             |           사용            | 설명                                                         |
| :--: | :-------------------------: | :-----------------------: | :----------------------------------------------------------- |
| 유저 |    임계 영역 기반 동기화    | 메모리 접근 동기화에 사용 | Critical Section Object(자료형 CRITICAL_SECTION인 객체)를 만들고 초기화 |
| 유저 |   인터락 함수 기반 동기화   | 메모리 접근 동기화에 사용 | 함수 내부적으로 한 순간에 하나의 쓰레드에 의해 실행되도록 동기화 |
| 커널 |     뮤텍스 기반 동기화      | 메모리 접근 동기화에 사용 | 키의 취득과 반납이 이루어짐(키 하나, 즉 동기화 대상 하나)    |
| 커널 |    세마포어 기반 동기화     | 메모리 접근 동기화에 사용 | 카운트를 통해 이루어짐(키 여러개, 즉 동기화 대상 여러개)     |
| 커널 | 이름있는 뮤텍스 기반 동기화 | 프로세스간 동기화에 사용  | 프로세스간에 동기화를 하기 위해 뮤텍스를 동기화 해야하는데 커널 오브젝트는 프로세스에 독립적이므로 뮤텍스에 이름을 붙여서 접근 |
| 커널 |     이벤트 기반 동기화      |  실행순서 동기화에 사용   |                                                              |



## Mutex & Semaphore & Monitor

#### 1. 뮤텍스와 모니터의 차이

- 뮤텍스는 다른 프로세스, 스레드 간 동기화를 위해 사용
- 모니터는 하나의 프로세스내에서 다른 스레드간의 동기화를 위해 사용
- 뮤텍스는 커널에 의해 제공된다 => 무겁고 느림
- 모니터는 라이브러리, 프레임워크에 자체에서 제공 => 가볍고 빠름



#### 2. 세마포어와 모니터의 차이

- 세마포어는 카운터라는 변수 값을 상호 배제 목적으로 매번 값의 수정 및 재지정이 일어난다
- 모니터는 이러한 일들이 캡슐화되어있어 synchronized, wait(), nofify()를 이용해 간단히 가능



#### 3. 뮤텍스와 세마포어의 차이

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다
- 세마포어는 소유 불가능, 뮤텍스는 소유 가능 그리고 소유주가 책임을 진다
- 뮤텍스의 경우, 뮤텍스 소유주가 뮤텍스를 해제할 수 있지만, 세마포어는 소유자가 아니더라도 해제 가능

##### 

#### Atomic Operation

> 실행 중에 중단하지 않는 순차적인 기계어 명령

세마포어 실행은 Atomic Operation이어야함

Atomic하지 않은 경우 → 명령어 도중 인터럽트 발생 → Context Switching이 발생 가능 → 동시 접근 허용 → 공유 자원 충돌 발생