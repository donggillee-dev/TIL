# JPA 소개



## 1.1 SQL을 직접 다룰 때 발생하는 문제점

- 진정한 의미의 계층 분할이 어렵다
- 엔티티를 신뢰할 수 없다
- SQL에 의존적인 개발을 피하기 어렵다



## 1.2 패러다임 불일치

- 객체와 관계형 데이터베이스의 패러다임 불일치
- 서로 지향하는 목표가 다르기에 이런 패러다임 불일치가 일어난다
- 이러한 패러다임 불일치를 JPA가 중간 역할을 해줌으로써 해결 가능



### 1.2.2 연관관계

- 객체는 참조를 사용해서 연관관계를 가지며 참조를 이용해서 연관된 객체를 조회
  - 객체는 참조가 있는 방향으로만 조회 가능
- 테이블은 외래 키를 이용해서 연관관계를 가지며 조인을 이용해서 연관된 객체를 조회한다
  - 테이블은 외래 키 하나로 조인을 이용해 어느 방향에서나 조회 가능



### 1.2.3 객체 그래프 탐색

- SQL을 직접 다루면 **처음 실행하는 SQL**에 따라 객체 그래프를 어디까지 탐색할 수 있는지가 한정된다
  - 이는 곧 SQL에 한정적이며 의존적인 개발이다

#### JPA에서의 객체 그래프 탐색

- JPA는 연관된 객체를 사용하는 시점에 해당 객체와 관련된 SQL문을 실행
- 이를 **지연 로딩**이라고 한다

#### JPA와 비교

- JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장

  ```java
  Member member1 = jpa.find(Member.class, "1");
  Member member2 = jpa.find(Member.class, "1");
  
  System.out.println(member1 == member2); //true
  ```



### 1.2.5 정리

- JPA는 패러다임의 불일치를 해결해주고 정교한 객체 모델링을 유지하게 도와주는 것



## 1.3 JPA란 무엇일까?

> JPA는 자바 진영의 ORM 기술 표준이다
>
> ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치를 해결

- 다양한 ORM 프레임워크들이 존재하는데 그 중에 **하이버네이트 프레임워크**를 가장 많이 사용
- **하이버네이트를 기반**으로 새로운 자바 ORM 표준이 만들어졌는데 그게 **JPA**



### 1.3.2 왜 JPA를 써야하나?

- 생산성
  - JPA에게 저장할 객체를 전달하면 됨
- 유지보수
  - SQL 관련 코드를 JPA가 해결해주므로 유지보수성이 좋아진다
- 패러다임 불일치 해결
- 성능
  - 1차 캐시를 통해 최적화된 조회 및 통신
- 데이터 접근 추상화와 벤더 독립성
  - 다른 데이터베이스를 사용하게 된다면 JPA에게 다른 데이터베이스를 사용한다고 알려주기만 하면 된다.

