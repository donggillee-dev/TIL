# 고급 매핑

## 7.1 상속 관계 매핑

> 객체에서의 상속관계를 관계형 DB에 표현할 방법이 없다 (SuperType, SubType 관계라는 모델링 기법이 제일 유사)

해당 모델링 기법을 사용하기 위한 3가지 방식

1. 각각의 테이블로 변환
2. 통합 테이블로 변환
3. 서브타입 테이블로 변환



### 7.1.1 조인 전략(각각의 테이블로 변환)

1. @Inheritance(Strategy = InheritanceType.JOINED) => 조인 전략 지정
2. @DiscriminatorColumn(name = "DTYPE") => 부모 클래스에 구분 컬럼을 지정
3. @DiscriminatorValue("M") => 자식 엔티티 저장 시 구분 컬럼에 입력할 값을 지정

#### 장점

- 테이블이 정규화된다
- 저장공간을 효율적으로 사용

#### 단점

- 조회 시 조인이 많이 사용되므로 비용 상승
- 조회 쿼리가 복잡해진다



### 7.1.2 단일 테이블 전략

> - 테이블 하나에 다 때려 넣는다
> - 자식 객체들이 매핑한 컬럼들은 모두 Nullable 설정(모든 컬럼들이 다 들어가져 있기 때문)
> - 모든 컬럼이 다 들어가있기에 구분 컬럼은 필수



### 7.1.3 구현 클래스마다 테이블 전략

> - 자식 엔티티마다 테이블 생성
> - 이 방식은 보통 비추 ? => 여러 자식 테이블 조회시 UNION 사용, 자식 테이블 통합해서 쿼리하기 어려움



## 7.2 @MappedSuperclass

> - 추상 클래스와 비슷하다
> - 실제 테이블과 매핑되지 않는 클래스이다
> - 단순히 상속할 목적으로만 사용된다

- 주로 BaseEntity(어느 엔티티에나 공통적으로 들어가는 애들, Id)에서 사용된다

#### 특징

- 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모아주는 역할을 할 뿐
- 엔티티가 아니기에 `em.find()`, `JPQL`에서 사용 불가능
- 이 클래스는 직접 사용하는 경우가 거의 없기에 추상 클래스로 정의하는 것을 추천



`@Entity는 @Entity나 @MappedSuperclass로 지정한 클래스만을 상속받을 수 있다`



## 7.3 복합 키와 식별 관계 매핑

### 7.3.1 식별 관계 vs 비식별 관계

#### 식별 관계

- 부모 테이블의 기본 키를 받아 자식 테이블의 키본 키 + 외래 키로 사용하는 경우

#### 비식별 관계

- 부모 테이블의 키는 외래키로만 사용하고 자식은 고유의 키 값을 생성

  > 필수적 비식별 관계 : 외래키에 NULL을 허용하지 않음 -> 연관관계를 필수적으로 맺어야 한다
  >
  > 선택적 비식별 관계 : 외래키에 NULL을 허용 -> 연관관계를 선택적으로 맺을 수 있다
  >
  > 
  >
  > - 최근에는 `비식별 관계를 주로 사용`하고 필요한 곳에서만 식별 관계를 사용



### 7.3.2 복합 키 : 비식별 관계 매핑

#### @Id(데이터베이스에 가깝), @EmbeddedId(객체지향에 가깝) 두 방식이 존재

##### @EmbeddedId

- 복합키를 사용해야 하는 Entity내부에서 바로 사용 가능

- @EmbeddedId 어노테이션을 적어주기만 하면 된다
- 해당 엔티티에서 식별자 기본 조회시
  - @Id 방식은 해당 엔티티에서 바로 키를 주입해서 사용
  - @EmbeddedId 방식은 복합키 클래스를 세팅해주고 그 키를 기반으로 해당 엔티티 내에서 조회



### 7.3.6 식별, 비식별 관계의 장단점

- `식별 관계`는 부모 테이블의 기본 키를 자식으로 전파
  - 즉 자식 관계가 계속 생겨나면 자식들의 기본 키 컬럼이 엄청 많아진다
- `식별 관계`는 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많음
- `비식별 관계`는 비즈니스 의미가 없는 대리 키를 사용한다
- 식별 관계는 부모와 자식간에 기본키로 엮여있으므로 유연하지 못하다
  - 그래서 객체지향 관점에서 주로 비식별 관계를 선호
- 복합 키는 별도의 복합 키 클래스를 만들어서 사용
- 비식별 관계의 기본키는 주로 @GenerateValue(GenerateType.AUTO)를 이용해서 사용하는 경우 많음

> 대부분은 비식별 관계를 사용하고 기본키는 Long 타입으로 대리 키를 만들어서 사용
>
> - 여기서 왜 Wrapper Class를 사용할까?
> - long 타입을 사용하게 되면 default값이 0으로 들어가게 된다
> - 0이라는 값은 이미 존재하는 값일 수도 있다
> - 그러므로 Wrapper Class를 이용하여 nullable하게 처리해줌으로써 0이라는 값을 식별자로써의 역할을 보장해준다

