# 영속성 관리

## 3.1 엔티티 매니저 팩토리 & 엔티티 매니저

#### 엔티티 매니저 팩토리

- 엔티티 매니저 팩토리는 보통 하나만 생성
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전
- 팩토리 생성시 커넥션 풀 생성

#### 엔티티 매니저

- 엔티티 매니저 팩토리에서 엔티티 매니저를 만든다

- 엔티티 매니저는 여러 스레드가 동시 접근하면 동시성 문제 발생하므로 공유하면 안된다

- 트랜잭션을 시작할 때 커넥션 획득, 그전까지는 x



## 3.2 영속성 컨텍스트

> - 엔티티를 영구 저장하는 환경
>
> - 엔티티 매니저로 엔티티를 조회, 저장하면 영속석 컨텍스트에 엔티티 보관하고 관리
>
> - 엔티티 매니저를 하나 생성할때 영속성 컨텍스트 하나 만들어짐



## 3.3 엔티티의 생명주기

#### 비영속

> 영속성 컨텍스트와 전혀 관계가 없는 상태

- 엔티티 객체를 생성한 상태
- DB나 영속성 컨텍스트와도 상관이 없는 상태

#### 영속

> 영속성 컨텍스트에 저장된 상태

- 영속성 컨텍스트에 의해 관리되어지고 있는 상태

#### 준영속

> 영속성 컨텍스트에 저장되었다가 분리된 상태

- 영속성 컨텍스트에 의해 관리되어지고 있다가 `em.detach()`나 `em.close()`를 호출하면 관리가 그만두어지는 상태

#### 삭제

> 삭제된 상태

- 엔티티를 영속성 컨텍스트와 DB에서 삭제함



## 3.4 영속성 컨텍스트의 특징

#### 식별자 값

- 영속성 컨텍스트는 엔티티를 식별자(@Id로 테이블의 Primary Key와 매핑한 값) 로 구분
- 즉 영속 상태는 식별자 값이 반드시 존재

#### 영속성 컨텍스트와 DB 저장

- JPA는 트핸잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 저장
  - **flush라고 한다**
- **장점**
  - 1차 캐시
  - 동일성 보장(==)
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩(Fetch 방식)

### 3.4.1 엔티티 조회

> 영속성 컨텍스트는 내부에 캐시를 가지고 있다 이를 1차 캐시라고 한다

- 영속성 컨텍스트 내부에 Map이 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스

- 조회하려는 엔티티를 DB에 접근해서 찾기 전에 우선 1차 캐시에서 조회함



#### 1차 캐시에서 조회

- 우선 1차 캐시에서 식별자 값으로 엔티티를 조회
- 엔티티가 있으면 DB안가고 메모리에 존재하는 엔티티를 반환

#### 데이터베이스에서 조회

- 해당 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회해서 엔티티 생성

#### 동일성 보장

- 동일한 엔티티 조회시 동일한 인스턴스를 반환



### 3.4.2 엔티티 등록

- 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 쌓아놓음
- 그리고 커밋시에 이 모아둔 쿼리들을 한번에 DB에 보낸다(**flush**)
- 이것을 ***쓰기 지연***이라고 한다



### 3.4.3 엔티티 수정

- SQL기반 시 수정 쿼리를 상황에 따라 추가 및 수정해야함
- 이는 수정 쿼리가 많아질 뿐더러 비즈니스 로직이 SQL에 의존하게 된다
- JPA에서는 어떻게 해결할까?

#### JPA의 변경 감지

- JPA로 엔티티를 수정할때는 단순히 엔티티 조회 -> 그 안의 정보 수정을 하면 된다

  ***How?***

  > JPA는 변경 감지를 통해 엔티티의 변경사항을 데이터베이스에 자동으로 반영
  >
  > - 이를 스냅샷이라는 기능을 통해 가능케 한다
  > - 스냅샷은 엔티티를 영속성 컨텍스트에 보관시 최초의 상태를 보관해두는 것을말한다

  ***절차***

  1. 트랜잭션 커밋 시 엔티티 매니저 내부 flush() 호출
  2. 엔티티의 스냅샷과 비교
  3. 변경사항에 대해서 Update 쿼리를 쓰기 지연 저장소에 넣어 놓는다
  4. 쓰기 지연 저장소의 SQL을 DB에 보낸다
  5. DB로 트랜잭션 커밋 ( flush() )

- JPA는 업데이트시 모든 필드를 업데이트 한다
  - 왜? 데이터 전송량 늘어나잖아
  - 모든 필드를 사용하면 수정 쿼리가 항상 같다
    - ex) update user set name = ? , value = ?
    - 데이터 바인딩만 하면됨, 틀은 항상 동일
    - 즉, 이전에 파싱된 쿼리를 재사용할 수 있다



### 3.4.4엔티티 삭제

- 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다
- 이것도 즉시 삭제하는 것이 아니라 엔티티 등록과 동일하게 쓰기 지연 저장소에 쿼리 저장
  - 참고로 em.remove(entity)를 하는 순간에 영속성 컨텍스트에서는 삭제됨



## 3.5 플러시

> flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

#### 실행 절차

1. 우선 변경 감지가 동작한다

   1-1. 이에 따라서 모든 엔티티를 스냅샷과 비교하고 Update쿼리를 쓰기 지연 저장소에 저장

2. 쓰기 지연 저장소의 SQL의 쿼리를 데이터베이스에 전송한다



#### Flush() 방식

1. em.flush()를 호출 (직접 호출)
2. 트랜잭션 커밋
3. JPQL 쿼리 실행 시
   - 쿼리를 수행하기 직전에 영속성 컨텍스트를 플러쉬해서 변경 내용을 반영한다
   - 그 이후 쿼리 수행
     - 다만 식별자를 기준으로 find()할 시에는 플러시 안일어남 왜?
     - 영속성 컨텍스트에 있다는 것은 식별자가 이미 존재한다는 것. 즉, 컨텍스트에서 엔티티 꺼내서 주면됨

### 3.5.1 플러시 모드 옵션

> 영속성 컨텍스트의 변경된 내용을 DB에 반영하는 것이 플러시다!

- FlushModeType.AUTO: 커밋이나 쿼리를 수행할 때 플러시
- FlushModeType.COMMIT: 커밋할때만 플러시



## 3.6 준영속

> 영속 상태였던 엔티티가 영속성 컨텍스트로부터 분리된 상태
>
> 즉, 영속성 컨텍스트가 제공하는 기능들을 사용할 수 없다

#### ***way***

1. em.detach(entity) : 특정 엔티티만 준영속으로
2. em.clear() : 영속성 컨텍스트를 완전히 초기화
3. em.close() : 영속성 컨텍스트를 종료

#### 

### 3.6.1 em.detach(entity)

- 영속성 컨텍스트에게 해당 엔티티 더 이상 관리하지 말라는 것
- 해당 메서드 호출 시 해당 엔티티 관련된 모든 정보가 캐시, SQL저장소에서 삭제된다

### 3.6.2 em.clear() 

- 영속성 컨텍스트를 초기화해서 내부에 있는 모든 엔티티들을 준영속 상태로 만듬

### 3.6.3 em.close()

- 영속성 컨텍스트를 아예 닫아버림

개발자가 직접 준영속 상태로 만드는 경우는 거의 없다. EntityManger를 닫으면서 보통 준영속 발생



### 3.6.4 준영속 특징

#### 거의 비영속

- 영속성 컨텍스트가 관리하지 않으므로 해당 기능들 모두 사용 불가

#### 식별자 값 존재

- 비영속 상태는 식별자 값이 없을 수도 있다
- 준영속 상태는 영속성 컨텍스트가 관리하다가 분리시킨 것이므로 식별자가 존재

#### 지연 로딩 불가능

- LAZY FETCH는 보통 프록시 객체 로딩해두고 실제 사용할 때만 영속성 컨텍스트를 이용해서 데이터를 불러오는 방식
- 즉 영속성 컨텍스트로부터 분리되었으니 지연 로딩 불가능



### 3.6.5 병합 merge()

> 준영속 상태의 엔티티를 다시 영속 상태로 만들기 위한 행위
>
> 준영속 엔티티를 받아서 그 정보를 기반으로 새로운 영속 상태의 엔티티를 반환

#### 순서

1. 파라미터로 넘어온 준영속 엔티티 식별자 값으로 1차 캐시에서 조회
2. 캐시에 없으면 db에서 조회
3. 조회한 값을 캐시에 저장하고 그 객체를 반환



- 파라미터로 넘어온 엔티티는 그대로 준영속 상태로 남아있는 것이다
- 엔티티 매니저가 영속성 컨텍스트에서 영속 상태의 엔티티를 새롭게 반환해주는 것임
- 따라서 준영속 상태를 참조하던 레퍼런스를 영속 상태의 객체를 참조하게끔 처리해주는 것이 안전하다



#### 비영속 병합

> 병합은 준영속 뿐만 아니라 비영속도 영속 상태로 만들 수 있다

- 파라미터로 넘어온 엔티티가 캐시에 존재하면 걔를 반환
- 캐시에 없고 DB에 존재하면 걔를 반환(update)
- DB에도 없다면 새로운 엔티티를 생성해서  병합(save)