# 프록시와 연관 관계

> 프록시
>
> - 연관된 객체를 자유롭게 탐색하기 위해 프록시라는 기술을 사용
>
> - 이를 통해 연관된 객체를 첨부터 조회하는 것이 아니라 실제로 사용하는 시점에 데이터베이스에서 조회할 수 있다
>
> - 즉시 로딩, 지연 로딩이라는 방법으로 둘을 모두 지원
>
> 영속성 전이, 고아 객체
>
> - 연관된 객체를 함께 저장, 삭제 용이



## 8.1 프록시

### 지연 로딩

> 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법
>
> - Ex) team.getName(), member.getOrder().get(0)
>
> 즉, 실제 데이터가 필요한 시점에 DB에서 조회해서 반환해주는 것

- 이런 지연 로딩이 가능하려면 실제 엔티티 객체 대신에 `데이터베이스 조회만 지원하는 가짜 객체`가 필요
- 이를 `프록시 객체`라고 한다



### 8.1.1 프록시 기초

#### 프록시 특징

- 프록시 객체는 실제 클래스를 상속 받아 생성되므로 실제 클래스와 겉 모양 동일
- 프록시 객체는 실제 객체에 대한 참조를 보관
- 프록시 객체의 메소드를 호출하면 실제 객체의 메소드를 호출
- 처음 사용될 때 한번만 초기화(`프록시 객체의 초기화`)
- 초기화 시 프록시 객체가 실제 엔티티로 바뀌는 것이 아님
  - 프록시 객체를 통해서 실제 엔티티에 접근이 가능한 것
- 영속성 컨텍스트에 해당 엔티티 존재하면 DB 조회할 필요도 없이 프록시를 반환하는 것이 아니라 실제 엔티티를 반환
- 프록시 객체의 초기화도 영속성 콘텍스트의 도움을 받아야 가능

#### 프록시 객체의 초기화

- member.getName()과 같이 실제 데이터를 조회할 때 실제 엔티티 객체가 생성
- 이것을 `프록시 객체의 초기화`라고 한다



### 8.1.2 프록시와 식별자

- 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달
- 프록시 객체는 이 식별자 값을 보관하고 있는다



## 8.2 즉시 로딩과 지연 로딩

> 지연 로딩시 프록시 객체가 사용된다

#### 즉시 로딩

- 엔티티 조회시 연관 엔티티도 바로 조회된다
- 보통 조인 쿼리를 사용

#### 지연 로딩

- 연관된 엔티티를 프록시로 조회
- 실제 사용시 초기화 하면서 DB 조회

- 연관된 엔티티를 실제 사용할 때 조회

  ```java
  Team team = member.getTeam(); //프록시 객체 반환
  team.getName(); //팀 객체 실제 사용, 엔티티 반환
  ```

#### 보통 추천하는 방식은 모든 연관관계에 지연 로딩을 사용하는 것, 즉시 로딩은 항상 외부 조인을 사용한다



## 8.4 영속성 전이

> 특정 엔티티의 영속성을 변경시에 연관된 엔티티들도 함께 변경하고 싶을때 사용하는 기능
>
> CASCADE

- JPA에서 저장할 때 연관된 모든 엔티티는 영속 상태이어야 한다

### 8.4.1 영속성 전이: 저장

- `CascadedType.PERSIST`를 부모 엔티티내의 자식들에 대해서 지정해놓으면

  ```java
  /* ...대략 부모 엔티티 하나 생성, 자식 둘 생성 코드... */
  em.persist(parent); //이거 하나로 자식들까지 저장처리 가능
  ```

  - 단지 엔티티 영속화시 연관된 엔티티들도 모두 영속화 가능하다는 편리함 제공

### 8.4.2 영속성 전이: 삭제

- `CascadeType.REMOVE`를 부모 엔티티에 설정

  ```java
  /* ...대략 부모 엔티티 하나 생성, 자식 둘 생성 코드... */
  em.remove(parent); //이거 하나로 자식들까지 모두 삭제 가능
  ```

  - 부모 엔티티 삭제시 연관된 자식들도 동일하게 삭제 처리 가능

#### CascadeType.PERSIST, CasecadeType.REMOVE 둘 다 flush()가 호출될 때 처리되는 것을 잊지말자!! :wave:



## 8.5 고아 객체

> 부모 엔티티로부터 연관관계가 끊어진 자식 엔티티에 대해서 자동 삭제처리 기능
>
> 부모 엔티티에서 특정 자식에 대한 참조만 끊음 -> 해당 자식은 고아 객체가 된다

- 부모 엔티티에서의 연관 객체 위에
  - `@OneToMany(mappedBy = "parent", orphanRemoval = true)` 이런 방식으로 한 뒤
  - 부모 엔티티의 컬렉션에서 특정 자식만 참조 제거 처리하면
  - 해당 자식 객체는 DB에서 삭제되게끔 처리
    - 이 로직도 바로 처리되는 것이 아니라 DELETE문이 쓰기 지연 SQL 저장소에 위치해 있다가
    - flush()가 호출되면 그때 처리한다
- 참조가 제거된 엔티티는 더 이상 다른 곳에서 참조되지 않는다는 것으로 보고 삭제 처리하는 것
- 즉, 참조가 한 곳에서만 일어나는 경우에 사용 가능
  - `@OneToMany`, `@OneToOne`

- 부모에서 자식의 참조를 끊는 경우도 있지만, 부모를 삭제하는 경우도 동일하게 처리
  - 부모 삭제 -> 부모와 연관되어 있던 모든 자식들 고아 객체가 된다
  - 모든 고아 객체는 삭제 처리 => `CascadeType.REMOVE`와 동일



## 8.6 영속성 전이 + 고아 객체, 생명주기

#### CascadeType.ALL + OrphanRemoval = true를 동시에 사용하면?

- 자식을 저장하려면 부모에 등록만 하면 된다(CASCADE)

- 자식을 삭제하려면 부모에서 참조를 끊으면 된다(OrpahnRemoval = true)