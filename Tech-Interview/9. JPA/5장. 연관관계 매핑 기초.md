# 연관관계 매핑 기초

> 방향 : 양방향, 단방향 존재, 방향은 객체에서만 존재하고 테이블 관계는 항상 양방향 관계
>
> 다중성 : 다대일, 일대다, 일대일, 다대다 다중성이 있다
>
> 연관관계의 주인 : 양방향 객체관계로 만들면 연관관계의 주인을 정해야 한다



## 5.1 단방향 연관관계

- 단방향 연관관계에서 해당 방향으로만 데이터의 조회가 가능, 그 반대는 불가능하다
- 테이블에서는 외래키 하나로 양방향 조회가 가능 => JOIN을 이용해서

#### 객체 vs 테이블 연관관계

- 객체는 주소로 연관관계를 맺는다
- 테이블은 외래키로 연관관계를 맺는다
- 객체는 참조, 테이블은 Join을 사용
- **객체간에 연관관계를 양방향으로 하고 싶으면 양쪽에 필드 추가해서 참조 보관해야함**
  - 양방향 관계가 아니라 사실상 서로 단방향 관계 2개임



### 5.1.3 객체 관계 매핑

#### @ManyToOne

- 이름 그대로 다대일 관계 의미
- 다중성을 나타내는 어노테이션을 필수로 사용해야 한다

#### @JoinColumn(name = "TEAM_ID")

- 외래 키와 매핑할 때 사용
- name 속성에는 매핑할 외래 키의 이름을 지정

> 이 값을 생략하게 되면 외래 키를 찾을 때 기본 전략을 사용
>
> 기본 전략
>
> - 필드명 + _ + 참조하는 테이블의 컬럼명



## 5.2 연관관계 사용

> JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태이어야 한다

### 5.2.2 연관관계에서의 조회

#### 객체 그래프 탐색

- 객체를 통해 연관된 엔티티를 조회할 수 있다
- 단순히 엔티티 내부의 getter를 사용하면 된다

#### 객체지향 쿼리 사용

- JPQL을 이용해서 Join 후 그 결과값 사용



### 5.2.5 연관된 엔티티 삭제

- 연관된 엔티티를 삭제하려면 연관관계를 모두 끊어주고 자식 -> 부모순으로 삭제해야함



## 5.3 양방향 연관관계

> JPA는 다양한 Collection을 제공한다



#### 5.3.1 양방향 연관관계 매핑

- 외래키의 선언과 동시에 해당 위치에 다중성을 명시해주어야함(기존 단방향에서 하는거처럼)

  ```java
  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  ```

- 그 반대편 엔티티에는 다중성과 함께 조인관계의 주체를 명시해주어야한다

  - mappedBy안에 반대편 매핑 필드의 변수명을 값으로 넣어주면 된다

  ```java
  @OneToMany(mappedBy="team")
  private List<Member> member = new ArrayList<Member>();
  ```



## 5.4 연관관계의 주인

##### mappedBy 왜씀??????

- 확실히 얘기하자면 양방향 연관관계는 테이블상에서 존재하는 것
- 객체에는 존재하지 않는 개념이다
- 객체에서는 그냥 단방향 두개를 놓은 것 뿐
  - 팀 -> 멤버
  - 멤버 -> 팀



##### 그래서 왜 쓰는데...?

> - 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하게 된다
>   - 즉 이 참조로 외래키를 사용하면 됨
>
> - But 양방향으로 하면 연관관계를 관리하는 위치는 두 곳으로 늘어난다
>   - 참조는 둘인데 외래키는 하나?
> - 이러한 차이점 때문에 연관관계의 주인을 지정해서 그곳에서 외래키를 관리하는 것



### 5.4.1 양방향 매핑의 규칙: 연관관계의 주인

#### 규칙

- 연관관계의 주인만이 데이터베이스 연관관계와 매핑된다
- 또한 외래 키를 등록, 수정, 삭제할 수 있다
- 주인이 아닌쪽은 읽기만 가능
- 주인관계는 주인이 아닌 엔티티에다가 `mappedBy`를 사용하면된다
- 주인은 `mappedBy`를 사용하지 않음
- 주인 == 외래키 관리자 == 외래키가 있는 엔티티
  - 주인만 외래키를 괸리하고 건들 수 있는데 그 외의 위치에 주인을 지정하면 외래키를 수정하고 관리하지 못하는 문제가 생긴다



## 5.6 양방향 연관관계의 주의점

> 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것이다



### 5.6.2 연관관계 편의 메소드

- 양방향 연관관계에서 양쪽을 다 신경써야하므로 양쪽을 매핑해주는 함수를 하나로 통일하는 것이 낫다

  ```java
  /*
  member.setTime(team);
  Team.getMembers().add(member);
  */
  
  //위 방식보다는 아래의 방식으로 처리하는 것이 더 효율적이고 에러 발생 적음
  //이를 연관관계 편의 메소드라고 한다
  public class Member {
    private Team team;
    
    public void setTeam(Team team) {
      this.team = team;
      team.getMembers().add(this);
    }
  }
  ```



### 5.6.3 연관관계 편의 메소드 주의사항

- 연관관계 편의 메소드에서 Critical한 버그가 있다

  ```java
  member.setTeam(teamA);
  member.setTeam(teamB);
  
  Member findMember = teamA.getMember(); //아직도 member가 조회된다
  ```

  - 위 코드에서 member의 팀을 최종적으로 teamB로 설정해주었는데도 teamA에서 해당 멤버가 조회된다
  - 즉, 양방향 관계인 teamA, member 관계에서 member -> teamA는 끊어줬는데 그 반대가 안 끊겼다
  - 위 코드, setTeam에서 그 참조를 제거해주어야 한다

  ```java
  public void setTeam(Team team) {
  	if(this.team != null) { //member와 연결된 team이 존재한다면
      this.team.getmembers().remove(this); //해당 team에서 이 멤버 제거
    }
    this.team = team; //이 멤버의 team을 들어오는 팀으로 등록
    team.getMembers.add(this);
  }
  ```



### 연관관계 주인을 정하는 기준

> 단방향은 항상 외래키가 있는 곳을 기준으로 매핑하면 된다 => ManyToOne or ManyToMany
>
> 양방향 매핑시 단순히 비즈니스 로직상 더욱 중요한 녀석을 주인으로 지정하면 안된다
>
> 주인은 단순히 `외래키 관리자`로 생각해야한다. 즉, 외래키가 있는 위치를 연관관계의 주인으로 설정하면 된다



### 양방향 매핑 시 주의해야할 것

> `무한 루프`에 빠지지 않도록 주의해야한다.
>
> 1. 어떠한 엔티티에 대해 toString()을 호출
> 2. 그 안에 있는 참조 엔티티에 대해 getter 동작
> 3. 참조 엔티티 내에서 toString() 호출
> 4. 다시 getter동작.... 무한루프
>
> 보통 이 과정은 무분별하게 Entity를 Controller에 넣어서 클라에게 반환할 때 많이 일어난다 ( 주로 JSON으로 변환할 떄 많이 일어남 )
>
> - 이를 해결하기 위해서는 `DTO와 Entity 용법을 분리`
> - 아니면 `JSON 직렬화 예외 처리`를 어노테이션을 통해서 하면 된다

